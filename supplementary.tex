\documentclass[10pt]{article}

% amsmath package, useful for mathematical formulas
\usepackage{amsmath}
% amssymb package, useful for mathematical symbols
\usepackage{amssymb}

% graphicx package, useful for including eps and pdf graphics
% include graphics with the command \includegraphics
\usepackage{graphicx}

% cite package, to clean up citations in the main text. Do not remove.
\usepackage{cite}

\usepackage{color} 

% Use doublespacing - comment out for single spacing
%\usepackage{setspace} 
%\doublespacing


% Text layout
\topmargin 0.0cm
\oddsidemargin 0.5cm
\evensidemargin 0.5cm
\textwidth 16cm 
\textheight 21cm

% Bold the 'Figure #' in the caption and separate it with a period
% Captions will be left justified
\usepackage[labelfont=bf,labelsep=period,justification=raggedright]{caption}

% Use the PLoS provided bibtex style
\bibliographystyle{PLoS2009}

% Remove brackets from numbering in List of References
\makeatletter
\renewcommand{\@biblabel}[1]{\quad#1.}
\makeatother


% Leave date blank
\date{}

\pagestyle{myheadings}
%% ** EDIT HERE **
%% Please insert a running head of 30 characters or less.  
%% Include it twice, once between each set of braces
\markboth{Evolutionary modeling}{Evolutionary modeling}

%% ** EDIT HERE **
%% PLEASE INCLUDE ALL MACROS BELOW
\input{defs.tex}
% no idea why \outside was redefined with a "\right," instead of a normal comma in defs.tex, but am redefining it back here - IH, 5/29/09
\renewcommand{\outside}[7]{\beta_{#1}\left(#2,#3,#4\right)}
%% END MACROS SECTION

\begin{document}

% Title must be 150 words or less
\begin{flushleft}
  {\Large
    \textbf{\titlestring: \supptext}
  }
\\
\authorstring
\end{flushleft}


\newpage
\tableofcontents

\newpage
\section{Exact elimination of SCFG null cycles}

The following section describes how to transform any SCFG so as to remove null cycles while preserving access to the full posterior probability distribution over parses, including parses with null cycles.

\subsection{Definitions}

Let $G = ( \Omega, \gnons, \grules, P )$ be a stochastic context-free grammar (SCFG)
consisting of
a set of terminal symbols $\Omega$,
a set of nonterminal symbols (a.k.a. ``states'') $\gnons$,
a set $\grules$ of {\em production rules} $L \to R$ (where $L \in \gnons$ and $R \in \grhs$)
and a probability function on the rules, $P:(\gnons \times \grhs) \to [0,\infty)$.

% (The rule set $\grules$ can be considered redundant to the specification of the grammar, in that $\rho \notin \grules \Leftrightarrow P(\rho)=0$.
% The interpretation is that $P$ is a probabilistic weight function and $\grules$ is informally the set of rules with non-zero weight.)

Let $\leftside{A}$ be the set of rules that can be applied to nonterminal $A \in \gnons$ (i.e., rules in which $A$ appears on the left),
and let $\rightside{A}$ be the set of rules that can generate nonterminal $A$ (i.e.,rules in which $A$ appears on the right, including bifurcations which also generate another nonterminal as well as $A$).
Let $\allrules{A} = \leftside{A} \cup \rightside{A}$ be the set of all rules involving $A$.
Define these also on sets of nonterminals, e.g., $\leftside{\gnulls} = \bigcup_{A \in \gnulls} \leftside{A}$ for $\gnulls \subseteq \gnons$.

Let $\gtrees$ be the set of all parse trees for $G$.
Suppose that parse tree $T \in \gtrees$ makes $n_T(\rho)$ uses of rule $\rho$;
then define the parse tree likelihood $P(T) = \prod_{\rho \in \grules} \left[ P(\rho) \right]^{n_T(\rho)}$.

If $\sum_{T \in \gtrees} P(T) = 1$, we say that $G$ is {\em probabilistically normalized by parse tree}.
If $\sum_{\rho \in \leftside{A}} P(\rho) = 1$ for all $A \in \gnons$, we say that $G$ is {\em probabilistically normalized by production rule}.
Note that normalization by production rule $\Rightarrow$ normalization by parse tree.

Let $S \in \Omega^\ast$ denote a terminal sequence.
Let $\mathrm{seq}:\gtrees \to \Omega^\ast$ be the function mapping a parse tree to its terminal sequence.
and let $\mathrm{root}:\gtrees \to \gnons$ be the function returning the root nonterminal of a parse tree.
The {\em inside probability of $S$ rooted at $A$} is $P(S|A)\ = \sum_{T: \mathrm{seq}(T) = S,\mathrm{root}(T) = A} P(T)$.
Of particular relevance to null state elimination is the probability $P(\epsilon|A)$,
where $\epsilon$ is the empty sequence.
This is the probability that a nonterminal $A$ will expire without generating any sequence.

Following earlier formalisms \cite{Durbin98,HolmesRubin2002a,Holmes2005},
we say that the grammar $G$ has {\em RNA normal-form rules} if
each rule in $\grules$ takes one of the following four forms:

\noindent \hrulefill
\begin{description}
\item[Termination rules] with one nonterminal on the left and the empty string on the right
\begin{eqnarray*}
A & \to & \epsilon
\end{eqnarray*}
\item[Transition rules] with one nonterminal on the left and the right
\begin{eqnarray*}
A & \to & B
\end{eqnarray*}
\item[Bifurcation rules] with one nonterminal on the left and two on the right
\begin{eqnarray*}
A & \to & B\ C
\end{eqnarray*}
\item[Emission rules] with one nonterminal on the left and right and at least one terminal on the right
\begin{eqnarray*}
A & \to & x\ B \\
A & \to & B\ y \\
A & \to & x\ B\ y
\end{eqnarray*}
\end{description}
\noindent \hrulefill

\noindent
Here $A,B,C \in \gnons$ and $x,y \in \Omega$.

Suppose that grammar $G$ has RNA normal-form rules.
We further say that $G$ has {\em RNA normal-form states} if
each nonterminal (state) $A \in \gnons$ takes one of the following forms:

\noindent \hrulefill
\begin{description}
\item[Null states]: $\leftside{A}$ contains only transition and termination rules.
\item[Bifurcation states]: $\leftside{A}$ contains exactly one bifurcation rule, $A \to X\ Y$, where $X \neq Y$ and $X,Y$ are both null states.
\item[Emit states]: $\leftside{A}$ contains only emission rules. Further, $\leftside{A} = \rightside{B}$ for some null state $B$.
This null state $B$ is called $A$'s {\em post-emit} state.
\end{description}
\noindent \hrulefill

Define a {\em null cycle} to be a nonterminal $A$
and a sequence of rules $\rho_1, \rho_2 \ldots \rho_k$ that, when applied consecutively to $A$, leave $A$ unchanged;
that is, $\rho_k(\rho_{k-1} \ldots \rho_2(\rho_1(A))) = A$.
Define a {\em null subtree} to be a null cycle using at least one bifurcation rule.

Suppose that $G = ( \Omega, \gnons, \grules, P )$ and $G' = ( \Omega, \gnons', \grules', P' )$ are two grammars.
We say that $G$ and $G'$ are {\em equivalent in sequence} if there is a mapping between nonterminals, $f:\gnons \to \gnons'$,
such that $P(S|A) = P(S|f(A))$.
We say that $G$ and $G'$ are {\em equivalent in parse} if there is a mapping between parse trees, $g:\gtrees \to \gtrees'$,
such that $P'(T') = \sum_{T:T'=g(T)} P(T)$ and we can define
\[
P(T|T') = P(T|g(T)=T') = \frac{P(T)}{P'(T')}
\]

Note that equivalence in parse $\Rightarrow$ equivalence in sequence.

Suppose that a grammar $G$ contains null cycles.
We seek to transform $G$ into a grammar $G''$ that is equivalent in parse and sequence, but has no null cycles.
If $G$ is normalized by parse tree, then $G''$ will be too; but $G''$ is not (necessarily) normalized by production rule.

We do the transformation in two steps, $G \to G' \to G''$.
We also provide a stochastic ``null cycle restoration'' algorithm for sampling from $P(T|T'')$.


\subsection{Eliminating null bifurcations}

Note first that any SCFG can be transformed into an equivalent one with RNA normal-form states by adding null states.
Without loss of generality, we therefore consider SCFGs with RNA normal-form states.

Let $G = ( \Omega, \gnons, \grules, P )$ be such an SCFG.
Let $\gnulls \subseteq \gnons$ be the set of null states in $\gnons$, {\bf excluding} post-emit states.
Let $\gemits \subset \gnons$ be the set of post-emit states.
Let $\gbifs \subseteq \gnons$ be the set of bifurcation states.

We here define the grammar $G'$,
\[
G' = \left( \Omega, \gnons', \grules', P' \right)
\]
which is equivalent to $G$ in sequence but has no null subtrees.

The new states $\gnons'$ are defined as follows.
Start with $\gnons$; remove bifurcation states;
then introduce a new state $N'$ for every null $N \in \gnulls$ and three new states $B^0, B', B^2$ for every bifurcation $B \in \gbifs$.

\[
\gnons' = 
\left( \bigcup_{N \in \gnulls} \{ N' \} \right) \cup \left( \bigcup_{B \in \gbifs} \{ B^0, B', B^2 \} \right) \cup \gnons \setminus \gbifs
\]

The idea is that $N'$ (in $G'$) is a null state that is equivalent to null state $N$ (in $G$) for non-empty sequence only.
That is, for any terminal sequence $S$,

\[
P'(S|N') = \left\{ \begin{array}{ll} P(S|N) & \mbox{if $S \neq \epsilon$} \\ 0 & \mbox{if $S = \epsilon$} \end{array} \right.
\]

Similarly, $B'$ is a null state that is equivalent to bifurcation state $B$ for non-empty sequence,
while $B^2$ is a null state that is is equivalent to $B$ for parse trees where both children of $B$ are non-empty.

In contrast, $B^0$ is {\bf exactly} equivalent to $B$ in sequence.
However, null subtrees in $B^0$ are explicitly accounted for,
their probabilities factored into the transitions $B' \to L'$ and $B' \to R'$ and the termination $B^0 \to \epsilon$,
using the inside probabilities for empty sequences, $P(\epsilon|L)$ and $P(\epsilon|R)$.

The probabilities $P(\epsilon|X)$ are related by the following system of equations

\[
P(\epsilon|X) = P(X \to \epsilon) + \sum_Y P(X \to Y) P(\epsilon|Y) + \sum_{L,R} P(X \to LR) P(\epsilon|L) P(\epsilon|R)
\]

which are nonlinearly coupled (via bifurcations) but may be solved numerically, e.g., by the Newton-Raphson method,
or by iterated approximation starting from a lower bound $P(\epsilon|X) \geq 0$.

The new rules and their probabilities are
\[
\begin{array}{rrcl}
\forall \rho \in (\grules \setminus \allrules{\gbifs}): & P'(\rho)             & = & P(\rho) \\
                                \forall N \in \gnulls: & P'(N' \to \epsilon)  & = & 0  \\
                          \ldots \forall B \in \gbifs: & P'(N' \to B')        & = & P(N \to B) \\
                         \ldots \forall M \in \gnulls: & P'(N' \to M')        & = & P(N \to M) \\
                         \ldots \forall E \in \gemits: & P'(N' \to E)         & = & P(N \to E) \\
               \forall (A \to B) \in \rightside{\gbifs}: & P'(A \to B^0)        & = & P(A \to B) \\
              \forall (B \to LR) \in \leftside{\gbifs}: & P'(B^0 \to \epsilon) & = & P(B \to LR)\ P(\epsilon | L)\ P(\epsilon | R) \\
                                                       & P'(B^0 \to B')       & = & 1 \\
                                                       & P'(B' \to \epsilon)  & = & 0 \\
                                                       & P'(B' \to L')        & = & P(B \to LR)\ P(\epsilon | R) \\
                                                       & P'(B' \to R')        & = & P(B \to LR)\ P(\epsilon | L) \\
                                                       & P'(B' \to B^2)       & = & 1 \\
                                                       & P'(B^2 \to L'\ R')   & = & P(B \to LR) \\
\end{array}
\]

Note that grammar $G'$, like $G$, has RNA normal-form states.
Note also that $G'$ is not, in general, normalized by production rule;
however, $G'$ is equivalent to $G$ in parse and is therefore normalized by parse tree (if $G$ is).

\subsection{Eliminating null states}

We now proceed to eliminate null cycles from $G'$.
Since null subtrees have been eliminated, the remaining null cycles use only transition rules.

We create the grammar
\[
G'' = \left( \Omega, \gnons', \grules'', P'' \right)
\]
which has the same nonterminals as $G'$, but different rules and rule probabilities.

Let $\gnulls' \subseteq \gnons'$ be the set of null states in $\gnons'$, {\bf including} post-emit states.

Define ${\bf t}$, the {\em transition matrix} of $G'$, as $t_{XY} = P'(X \to Y)$ for all $X,Y \in \gnons'$.
The effective transition probability $q_{XY}$ between two states $X,Y$
sums over all paths through null states (in the summand, $n$ is the length of the null path):
\[
{\bf q} = \sum_{n=0}^\infty {\bf t}^n = ({\bf 1}-{\bf t})^{-1}
\]
Here ${\bf 1}$ is the identity matrix.
The matrix inverse may be computed in the usual ways (Gauss-Jordan elimination, LU decomposition, etc.)

Since the bifurcation states of $G'$ explicitly generate non-empty sequence,
the system of equations relating the probabilities $P'(\epsilon|X)$ is completely linear
and may be solved in the same way.
Let $u_X = P'(\epsilon|X)$ and $v_X = P'(X \to \epsilon)$.
Then

\[
{\bf u} = {\bf v} + {\bf tu}
\]

whose solution is ${\bf u} = {\bf qv}$.
Thus $P'(\epsilon|X) = \sum_Y q_{XY} P'(Y \to \epsilon)$.

We now define $P''$ as follows.
\begin{itemize}
\item For all rules $\rho \in \grules'$ that are {\bf not} transitions or terminations, set $P''(\rho) = P'(\rho)$.
\item For terminations from null states $X \in \gnulls'$, set $P''(X \to \epsilon) = u_X$.
(NB this may create some terminations $X \to \epsilon$ that were not present in $G'$.)
\item For transitions from null states $X \in \gnulls'$ to non-null states $Y \notin \gnulls'$, set $P''(X \to Y) = q_{XY}$.
(NB this may create some transitions $X \to Y$ that were not present in $G'$.)
\item For transitions {\bf to} null states $X \in \gnulls'$, set $P''(A \to X) = 0$.
\end{itemize}

Although we have left null states in $G''$, they now have no incoming transitions
and are inaccessible unless they are post-bifurcation states (i.e.,states which appear on the right-hand side of bifurcation rules), post-emit states, or the start (root) state.
All other null states can therefore be dropped from $\gnons''$.

\subsection{Restoring null states}

Suppose that $\rho''$ is a rule in $G''$.
Algorithm~\ref{alg:restoreTransitions} samples from the distribution of equivalent parse subtrees in $G'$ (possibly containing null cycles).
In order to sample from $P(T'|T'')$ we need simply map Algorithm~\ref{alg:restoreTransitions} to each rule in $T''$.

For parameter estimation by Expectation Maximization and some other applications, it is useful to know the expected number
of times that a transition was used, summed over the posterior distribution of parse trees (including those with null cycles).
If $n''(\rho'')$ is the expected number of times that transition $\rho''$ was used according to an Inside-Outside computation on $G''$,
then the corresponding expectations $n'(\rho')$ are given by

\begin{eqnarray*}
       n'(X \to Y) & = & n''(X \to Y) \frac{P''(X \to Y)}{q_{XY}} + \sum_Z n''(X \to Z) \frac{P''(X \to Y) q_{YZ}}{q_{XZ}} \\
n'(X \to \epsilon) & = & n''(X \to \epsilon) \frac{P''(X \to \epsilon)}{P''(\epsilon | X)}
 + \sum_W n''(W \to \epsilon) \frac{q_{WX} P''(X \to \epsilon)}{P''(\epsilon | W)}
\end{eqnarray*}

Expectations for other rules (bifurcations and emissions) are the same for $G'$ as $G''$.


\subsection{Restoring null bifurcations}

Suppose that $\rho'$ is a rule in $G'$.
Algorithm~\ref{alg:restoreBifurcations} samples from the distribution of equivalent parse subtrees in $G$ (possibly containing null subtrees).
This algorithm also calls Algorithm~\ref{alg:sampleNullSubtree}, which samples from the distribution of empty subtrees rooted at a particular nonterminal.
In order to sample from $P(T|T')$ we need simply map Algorithm~\ref{alg:restoreBifurcations} to each rule in $T'$.

If $n'(\rho')$ is the expected number of times that rule $\rho'$ was used by $G'$,
then the corresponding expectations $n(\rho)$ are given by

\begin{eqnarray*}
    n(B \to L\ R) & = & n'(B' \to L') + n'(B' \to R') + n'(B^0 \to L'\ R') + d(B \to L\ R) \\
       n(X \to Y) & = & n'(X \to Y) + d(X \to Y) \\
n(X \to \epsilon) & = & n'(X \to \epsilon) + d(X \to \epsilon)
\end{eqnarray*}
Expectations for emissions are the same for $G$ as $G'$.
In the above expressions $d(\rho)$ is the expected usage of rule $\rho$ by null subtrees:

\[
d(\rho) = \sum_{(B \to LR) \in \grules} \left[
n'(B' \to L') c_R(\rho)
+ n'(B' \to R') c_L(\rho)
+ n'(B^0 \to \epsilon) (c_L(\rho) + c_R(\rho))
\right]
\]

where $c_W(\rho)$ is the expected usage of rule $\rho$ by an empty parse tree rooted at $W$,
given by

\begin{eqnarray*}
c_X(\rho) P(\epsilon | X) & = & P(X \to \epsilon) \delta_{\rho=(X \to \epsilon)}
 + \sum_Y P(X \to Y) P(\epsilon|Y) \left( c_Y(\rho) + \delta_{\rho=(X \to Y)} \right)
\\ & &
 + \sum_{L,R} P(X \to LR) P(\epsilon|L) P(\epsilon|R) \left( c_L(\rho) + c_R(\rho) + \delta_{\rho=(X \to LR)} \right)
\end{eqnarray*}

where $\delta_U$ is the Kronecker delta (1 if condition $U$ is true, 0 if it is false).
Note that in contrast to the system of equations for $P(\epsilon|X)$, this is a linear system of equations
of the form ${\bf c} = {\bf Mc} + {\bf k}$, which may be solved by matrix inversion:
${\bf c} = ({\bf 1}-{\bf M})^{-1} {\bf k}$.



\newpage
\section{Two-sequence transducer models}

We here give formal definitions of two-sequence models and the state machines which
generate the factored probability distribution $P (X, Y | \Delta T) = P (X) \cdot P (Y | X, \Delta T)$,
where the marginal $P(X)$ is generated by a {\bf singlet transducer}
and the conditional $P (Y | X, \Delta T)$ by a {\bf branch transducer}.
We refer to the branch transducer as $\theta$, so the conditional distribution
is more precisely $P (Y | X, \Delta T, \theta)$.


\subsection{Formal grammars} \seclabel{grammars}

There is a close relationship between formal grammars and the singlet and branch transducer abstract state machines.
By labeling the nonterminals of a regular or stochastic context-free grammar (SCFG) as states of an abstract machine, allowing these states to absorb and emit 
appropriate terminal symbols,\footnote{The relationship between formal grammars and abstract state machines is more transparent
in the Mealy machine view, but the Moore machine view turns out to be more useful for our purposes.},
and carefully assigning transition and emission weights,
we can create a state machine which generates the same language, with the same distribution of weights, as that produced by the original grammar.\footnote{We speak of
weights associated with a transition rather than probabilities in order to allow for more general models.}
We therefore use the terms ``nonterminal'' and ``state'' interchangeably
and refer to the ``parse tree'' generated by singlet and branch transducers.

Phrased more precisely, there is an isomorphism between the singlet and branch transducers of two-sequence models
and Pair SCFGs.  Practically speaking, this means that for every joint distribution $P(X, Y | \Delta T)$ 
generated by a singlet and branch transducers, there exists a Pair SCFG which generates the same distribution.

\subsection{States, transitions and emissions}
A singlet transducer has states of type $\Sstart$ and $\Sinsert$.
Each state $\phi\in\Phi$ of the branch transducer has type
\[ \type(\phi) \in \lbrace\Sstart,\,\Sinsert,\,\Smatch,\,\Swait,\,\Send\rbrace \, . \]
State typing is as follows:
\begin{itemize}
  \item A $\Sstart$ state begins a branch of the parse tree.
  \item An $\Sinsert$ state emits, but does not absorb, symbols.
  \item A $\Smatch$ state absorbs and (possibly) emits symbols.
  \item A $\Swait$ state is a null state which allows a branch transducer to ``pause''
    while it waits for an input symbol from another transducer.
    In the two-sequence case, the input symbols is emitted by the singlet transducer generating
    the ancestral sequence.
  \item An $\Send$ state ends a branch of the parse tree.
\end{itemize}
The names of state types are similar to the $\{\Sstart,\,\Sinsert,\,\Smatch,\,\Send\}$ states of the familiar Pair HMM.
Deletions are handled as a special case by states of type $\Smatch$ which absorb but do not emit symbols pairs.
Only states of type $\Smatch$ can absorb symbol pairs $(x,y)$.

Bifurcations in the grammar, when considered as emission of nonterminals, can be handled analogously
to terminal emission.  States $\phi: \type(\phi) \in \{\Sinsert,\,\Smatch\}$ can emit nonterminal pairs $(c\,d)$,
where $c$ or $d$ can be the null symbol, and the emitted pairs $(c\,d)$ can be absorbed by states of type $\Smatch$.

The emission weight of a nonterminal pair $(c\,d)$ from the state $b: \type(b) = \Smatch$, 
conditional on absorption of a nonterminal pair $(l\,m)$, is 
\[ e_b ( c\,d|l\,m,\theta ) \, . \]

The functions $\emit()$ and $\absorb()$ are defined to return the emission or absorption of a particular state,
\begin{align*}
  \emit(\phi) &:= \left\{\begin{array}{ll} (x,y) & x,y = \mathrm{terminal\,\,or\,\,null} \\(c\,d) & c,d = \mathrm{nonterminal\,\,or\,\,null}. \end{array} \right. \\
  \absorb(\phi) &:= \left\{\begin{array}{ll} (x,y) & x,y = \mathrm{terminal\,\,or\,\,null} \\(c\,d) & c,d = \mathrm{nonterminal\,\,or\,\,null}. \end{array} \right.
\end{align*}

We frequently use the notation ${}^{uv}\phi^{xy}$ to indicate that a state of type $\Smatch$ absorbs a symbol pair $(u,v)$
and emits a pair $(x,y)$.
The notation for bifurcations is slightly different:
A bifurcation state which left-emits a nonterminal $d$ and makes a transition to a state $\phi$ with weight 1 is written as $\bifurc{B}{d}{\phi}$.

A transition between states $a$ and $b$ of the branch transducer $\theta$ has a weight
\[ t(a,b|\theta) = t(a \to b|\theta). \]
Terminal emission is handled by states $\phi: \type(\phi) \in \{\Smatch,\,\Sinsert\}$, which emit symbol pairs $(x,y)$,
where $x$ or $y$ can be the null symbol.
In this paired-emission perspective, left single-terminal emissions $x$ are represented as $(x\,\Tnull)$;
right single-terminal emissions are handled similarly.
The weight of an emission of a terminal pair $(x,y)$ from a state $b: \type(b) = \Smatch$, 
conditioned on absorption of a terminal pair $(u,v)$, is 
\[ e_b ( x,y|u,v,\theta ) \, . \]
Recall that the emission weights of states of type $\Smatch$ are defined conditioned upon the absorbed symbols.


\newpage
\section{Multiple-sequence transducer models} \seclabel{evolutionarymodels}

We can use our two-sequence models to construct a model of many sequence related by a
guide phylogenetic tree.
The guide tree specifies the (conjectured) phylogenetic relationship of all sequences.
A singlet transducer, which emits, but does not absorb, symbols, lies at the root of the guide tree and 
serves as a generative model of the ancestral sequence.
A branch transducer represents the evolution of an ancestral sequence into a single descendant 
sequence, that is, the action of evolution along the single-branch tree (Ancestor $\to$ Descendant).
To represent the evolution of an ancestral sequence into many descendant sequences
(whose phylogenetic relationship is specified by the guide tree),
we place a branch transducer on each branch of the guide tree to create a multiple-sequence model.

If the branch grammar has no bifurcations and only left or right emissions are allowed, then
the language generated is a regular string language and the corresponding jointly normalized abstract state machine is 
an HMM.  In this simplest case our formalism for creating a multiple-sequence model reduces to that given 
by \cite{Holmes2003} for combining HMMs on a guide tree.


\subsection{The guide tree}
The nodes of the tree are labeled $1,\dots,N$ in the order reached by any preorder depth-first traversal of the tree.
The length of each branch $(\parent(m) \to m)$ is given by the evolutionary time $t_m$.
To specify ancestor-descendant relationships, we introduce notation:
$\mDn$ ($\mNDn$) means node $m$ is descended from (not descended from) node $n$, and
$\mDEn$ ($\mNDEn$) means node $m$ is descended from or identical to (not descended from and not identical to) node $n$.

\subsection{States, transitions and emissions}
The multiple-sequence model is formed by the composition/intersection of $(N-1)$ branch transducers 
such that there is a branch transducer on each branch $(\parent(m) \to m);\, m = 2,\dots,N$ of the guide tree and a singlet transducer at the root node.
Our framework allows for the placement of different branch transducers, with a unique set of nonterminals (state space) $\Phi$ and
allowed transitions between states and corresponding weights, on each branch.  $\theta^{(m)}$ denotes 
the branch transducer governing evolution along the branch $(\parent(m) \to m)$ of the guide tree.

States of the multiple-sequence model are represented by as N-dimensional vectors $\bvec{a}$,
\[ \bvec{a} = \statevec{a} \, . \]
These states are typed as
\[ \type(\bvec{a}) \in \lbrace\Sstart,\,\Semit,\,\Sbifurc,\,\Snull,\,\Send\rbrace \, . \]
State typing is as follows:
\begin{itemize}
  \item A $\Sstart$ state begins a branch of the parse tree of one or more of the $N$ sequences on the phylogenetic tree.
  \item An $\Semit$ state emits symbols (terminals) to one or more of the $N$ sequences.
  \item A $\Sbifurc$ state corresponds to a bifurcation in the parse tree of
    one or more of the $N$ sequences.
  \item A $\Snull$ state corresponds to any non-$\Send$ state which represents neither
    an emission or bifurcation.
  \item An $\Send$ state ends a branch of the parse tree.
\end{itemize}
States are typed according to the transition by which they are reachable
(details of the typing are given in \secref{transitions}).

Transitions and emissions of the multiple-sequence model are defined in terms of the transitions and emissions 
of the branch transducers at each node as well as the singlet transducer at the root node.
The weight of a transition $\bvec{a} \to \bvec{b}$ is therefore
\beqn
t(\bvec{a},\bvec{b}) = \prod_{m|a_m \ne b_m} \transweight{m}{a_m}{b_m} \, ,
\eeqn
and the weight of an emission $(\bvec{x}\,\bvec{y})$ from a state $\bvec{b}$ is
\beqn
\totalemissionweight{\bvec{b}}{\bvec{x}\,\bvec{y}} = \prod_m e_{b_m}\left(x_m\,y_m|x_{\parent(m)}\,y_{\parent(m)},\theta^{(m)}\right) \, .
\eeqn
We frequently will not explicitly write out the conditional dependence on the absorbed terminals $(x_{\parent(m)}\,y_{\parent(m)})$,
but the reader should keep in mind that in general emission weights will depend on the absorbed symbols.

\subsection{Formal grammars} \seclabel{multigrammars}

Analogously to the case with two-sequence models (\secref{grammars}),
there exists a one-to-one mapping between the multiple-sequence models generated by our model-construction algorithm 
and multi-sequence SCFGs.
In other words, given a singlet and branch transducers of a two-sequence model, as well
as a guide tree relating the extant sequences, there exists a corresponding multi-sequence SCFG
which generates the same joint probability distribution $P(X_1 , ... , X_n)$.



\subsection{Constructing the state graph} \seclabel{stategraph}

As described in the paper,
we need a way to efficiently construct the state graph of the multi-sequence model,
where the state graph consists of a list of accessible states and the possible transitions between them.
This state graph can be constructed by an uninformed depth-first search,
where at each step of the search we obtain the possible child nodes 
by applying one of the following possible transitions of the multi-sequence model:
\begin{enumerate}
\item {\bf Null transition}:
  The state of a single branch transducer is updated, with no terminal emission or bifurcation.
\item {\bf Terminal emission}:
  A state makes a transition to a $\Sinsert$ state.  The emitted symbol is passed down the guide
  tree to all descendant branch transducers, which transition to states of type $\Smatch$.
\item {\bf Bifurcation}:
  A state makes a transition to a special $\Sinsert$ state which emits a new branch of the parse tree.
  The emitted symbol is passed down the guide tree to all descendant branch transducers, 
  which transition to states of type $\Smatch$.
\item {\bf End transition}:
  The singlet transducer associated with the root sequence can transition to the $\Send$ state,
  signaling that this parse tree is finished.
\end{enumerate}

Each of these transitions is explained in detail in the following section.



\subsection{Allowed transitions} \seclabel{transitions}

Following \cite{Holmes2003},  we let transitions of the multi-sequence model begin at the active node and cascade down the guide tree
as appropriate.  Unless defined otherwise, node $n$ is the active node of the multi-sequence model with state $\bvec{a}$, 
\begin{align}
  n &= \activenode{a} \\
  &= \mathrm{argmax}_m \left\{\type(a_m) \notin \{\Swait,\,\Send\}\right\} \, . \label{eqn:activenode} 
\end{align}
Each possible allowed transition is obtained by making a valid change (updating) the 
state of the singlet or one or more of the branch transducers of the multi-sequence model.


\subsubsection*{Null Transitions}

\[ \statevec{a} \to \statevec{b} \]

\begin{align} \label{eqn:nulltransition}
  \type(\bvec{b}) &= \Snull  \\
  \weight(\bvec{a}\to\bvec{b}) &= t(\bvec{a},\bvec{b}) \\
  &= \transweight{n}{a_n}{b_n} .
\end{align}

This transition updates the state of the branch transducer at the active node $n$ of the guide tree, leaving 
the rest unchanged, with no corresponding terminal emission or bifurcation in the grammar.
Nodes other than the active node do not change state, $a_m = b_m \,\forall\, m \ne n$, and the only 
allowable transitions of this form are to states $b_n:\,\type(b_n) \in \{\Sstart,\,\Swait\}$.  Transitions
to states of type $\Sinsert$ or $\Smatch$ result in emissions, and transitions to the end state $\Send$
are handled as a special case.


\subsubsection*{Terminal Emission} \seclabel{terminalemission}
\[ \statevec{a} \to \statevec{x}\,\statevec{b}\,\statevec{y} \]

\begin{align} \label{eqn:terminalemission}
  \type(\bvec{b}) &= \Semit \\
  \weight(\bvec{a}\to\bvec{x}\,\bvec{b}\,\bvec{y}) &=  t(\bvec{a},\bvec{b}) \cdot \totalemissionweight{\bvec{b}}{\bvec{x}\,\bvec{y}} \\
  &= \left[ \prod_{m|a_m \ne b_m} \transweight{m}{a_m}{b_m} \right] \cdot \left[ \prod_m \emissionweight{m}{b_m}{x_m\,y_m} \right] ,
\end{align}
where we are defining states with no emissions to emit $(\Tnull\,\Tnull)$ with weight 1, 
$\emissionweight{m}{b_m}{x_m\,y_m} = 1$ if $(x_m\,y_m) = (\Tnull\,\Tnull)$ and $\emit(b_m) = \Tnull$.

The active node $n$ makes a transition to a state $b_n:\,\type(b_n) = \Sinsert$, emitting
a terminal symbol pair $\emit(b_n) = (x_n\,y_n)$.  This symbol pair is passed down the guide tree to descendant nodes $\{m|\mDn, \type(a_m) \ne \Send\}$, 
forcing them to make a transition from states of type $\Swait$ to states of type $\Smatch$, which can absorb
terminal pairs $(x,y)$.  Qualitatively, this transition and emission could represent the evolution
of two paired nucleotides along the subtree rooted at node $n$ of the complete guide tree.
If one of $\bvec{x}$ or $\bvec{y}$ is null, then \eqref{eqn:terminalemission} could represent the evolution of
a single unpaired nucleotide along the subtree rooted at node $n$.


\paragraph{Left emission.}
All terminals $\bvec{y}$ in the transition $\bvec{a} \to \bvec{x}\,\bvec{b}\,\bvec{y}$ \eqref{eqn:terminalemission} are null.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(x_m\,y_m) = (\Tgap\,\Tnull)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(x_n\,y_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m) = (x_{\parent(m)}\,\Tnull)$. \\
  & $(x_m\,y_m) = \left\{ \begin{array}{ll} (\Tgap\,\Tnull) & \emit(b_m) = \Tnull \\ \emit(b_m) & \emit(b_m) \ne \Tnull \end{array} \right. $
\end{tabular}

\paragraph{Right emission.}
All terminals $\bvec{x}$ in the transition $\bvec{a} \to \bvec{x}\,\bvec{b}\,\bvec{y}$ \eqref{eqn:terminalemission} are null.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(x_m\,y_m) = (\Tnull\,\Tgap)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(x_n\,y_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m) = (\Tnull\,y_{\parent(m)})$. \\
  & $(x_m\,y_m) = \left\{ \begin{array}{ll} (\Tnull\,\Tgap) & \emit(b_m) = \Tnull \\ \emit(b_m) & \emit(b_m) \ne \Tnull . \end{array} \right. $
\end{tabular}

\paragraph{Paired emission.}

There is at least one non-null terminal in both $\bvec{x}$ and $\bvec{y}$ in the transition $\bvec{a} \to \bvec{x}\,\bvec{b}\,\bvec{y}$ \eqref{eqn:terminalemission}.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(x_m\,y_m) = (\Tgap\,\Tgap)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(x_n\,y_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m) = (x_{\parent(m)}\,y_{\parent(m)})$. \\
  & $(x_m\,y_m) = \left\{ \begin{array}{ll} (\Tgap\,\Tgap) & \emit(b_m) = \Tnull \\ \emit(b_m) & \emit(b_m) \ne \Tnull . \end{array} \right. $
\end{tabular}


\subsubsection*{Bifurcations}
\[ \statevec{a} \to \statevec{c}\,\statevec{b}\,\statevec{d} \]

\begin{align} \label{eqn:nonterminalemission}
  \type(\bvec{b}) &= \Sbifurc \\
  \weight(\bvec{a}\to\bvec{c}\,\bvec{b}\,\bvec{d}) &=  t(\bvec{a},\bvec{b}) \cdot \totalemissionweight{\bvec{b}}{\bvec{c}\,\bvec{d}} \\
  &= \left[ \prod_{m|\,a_m \ne b_m} \transweight{m}{a_m}{b_m} \right] \cdot \left[ \prod_m \emissionweight{m}{b_m}{c_m\,d_m} \right] .
\end{align}
where we are defining the emission weight of the $\Send$ nonterminal to be 1, $\emissionweight{m}{b_m}{c_m\,d_m} = 1$ if $c_m = \Send$ or $d_m = \Send$.

Bifurcations are handled similarly to terminal emission.  The active node $n$ can undergo a bifurcation by making a transition 
$a_n \to b_n,\, b_n:\,\type(b_n) = \Sinsert$, emitting a pair of nonterminals $\emit(b_n) = (c_n\,d_n)$.  Descendant nodes $\{m|\mDn,\type(a_m) \ne \Send\}$
are forced to make a transition from states of type $\Swait$ to states of type $\Smatch$ which can absorb nonterminal pairs $(c\,d)$.
All emissions are pairwise, so left and right bifurcations are represented as pairs $(\bvec{c}\,\bvec{d})$ where either $\bvec{c}$ or $\bvec{d}$ is null.
If $\bvec{d}$ is null, then \eqref{eqn:nonterminalemission} could represent the insertion and subsequent evolution of a new RNA stem-loop structure.

\paragraph{Left bifurcation.}
All nonterminals $\bvec{d}$ in the transition $\bvec{a} \to \bvec{c}\,\bvec{b}\,\bvec{d}$ \eqref{eqn:nonterminalemission} are null.
The nonterminals $\bvec{c}$ are the ``new'' states (for example, corresponding to a newly formed stem);
the nonterminals $\bvec{b}$ are the states which will generate the (evolved) ancestral sequence.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(c_m\,d_m) = (\Send\,\Tnull)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(c_n\,d_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m)$ \\
  & $(c_m\,d_m) = \emit(b_m) . $
\end{tabular}


\paragraph{Right bifurcation.}
All nonterminals $\bvec{c}$ in the transition $\bvec{a} \to \bvec{c}\,\bvec{b}\,\bvec{d}$ \eqref{eqn:nonterminalemission} are null.
The nonterminals $\bvec{d}$ are the ``new'' states;
the nonterminals $\bvec{b}$ are the states which will generate the (evolved) ancestral sequence.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(c_m\,d_m) = (\Tnull\,\Send)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(c_n\,d_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m)$ \\
  & $(c_m\,d_m) = \emit(b_m) . $
\end{tabular}

\paragraph{Paired bifurcation}
There is at least one non-null nonterminal in both $\bvec{c}$ and $\bvec{d}$ in the transition $\bvec{a} \to \bvec{c}\,\bvec{b}\,\bvec{d}$ \eqref{eqn:nonterminalemission}.
The nonterminals $\bvec{c}$ and $\bvec{d}$ are both ``new'' states;
the nonterminals $\bvec{b}$ are the states which will generate the (evolved) ancestral sequence.

\begin{tabular}{rl}
  Nodes $\mNDEn$: & $a_m = b_m$. \\
  & $(c_m\,d_m) = (\Send\,\Send)$. \\
  Node $n$: & $b_n:\,\type(b_n) = \Sinsert,\,\exists$ a transition $a_n \to b_n$ in the branch transducer $\theta^{(n)}$. \\
  & $(c_n\,d_n) = \emit(b_n)$. \\
  Nodes $\mDn$: & Either $a_m = b_m$, $\emit(b_{\parent(m)}) = \Tnull$ or $\type(a_m) = \Send$ \\
  & $\quad$ or $\emit(b_{\parent(m)}) = \absorb(b_m)$ \\
  & $(c_m\,d_m) = \emit(b_m) . $
\end{tabular}

This paired-bifurcation is included for completeness--for example, it could be used to model symmetric loops--but it
increases the complexity of grammar parsing.



\subsubsection*{Transition to $\Send$}
\[ \statevec{a} \to \Send \]

\begin{align} \label{eqn:transtoend}
  \weight(\bvec{a}\to\Send) &=  t(\bvec{a},\Send) \\
  &= \prod_{m|\type(a_m)\ne\Send} \transweight{m}{a_m}{\Send} .
\end{align}

The singlet transducer associated with the highest active ancestral node,
\beqn
\hat{n} = \argmin_m \left\{ \type(a_m) \in \{\Sstart,\,\Sinsert\} \right\}
\eeqn
can make a transition to the state $\Send$,
forcing the entire multi-sequence model to transition to $\Send$.\footnote{The node $\hat{n}$ which initiates the transition to $\Send$ 
is the root of the greatest active subtree of the whole guide tree (called such because $a_m = \Send \, \forall \, m \ntrianglerighteq \hat{n}$).}
If the branch transducer does not permit inserted bifurcations then $\hat{n} = 1$ always,
but this is generically not true for a more general grammar
(for example, see the TKF Structure Tree model).

We require:

\begin{tabular}{rl}
  Nodes $m \ntrianglerighteq \hat{n}$: & $a_m = \Send$. \\
  Node $\hat{n}$: & $\type(a_{\hat{n}}) \in \{\Sstart,\,\Sinsert\}$ \\
  & $\exists$ a transition $a_{\hat{n}} \to \Send$.  \\
  Nodes $m \vartriangleright \hat{n}$: & $\type(a_m) = \Swait$ \\
  & $\exists$ a transition $a_m \to \Send$. \\
\end{tabular}

In many probabilistic models, the transition from a state of type $\Swait$ to the $\Send$ state has weight 1 conditional on absorbing 
the $\Send$ symbol (called $\epsilon$ in formal grammar theory),
but we here allow for a more general contribution to the total weight $\mathbb{F}$ of the transition.

$\hat{n}$ and $\weight(\bvec{a}\to\Send)$ are so defined in order to ensure that there exists a direct path
along which the end symbol can be passed down the tree.
The grammar should be designed such that if the singlet transducer at node $\hat{n}$ can make a transition to $\Send$,
then so can all machines at $\{m|m \trianglerighteq \hat{n}\}$.
The TKF Structure Tree model (\secref{tkfst}) satisfies this condition.
A more general approach is probably possible, but it involves summing over paths $a': a_m \to a' \to \Send$,
handling possible bifurcations in these paths, etc.



\newpage
\section{The TKF Structure Tree model as a transducer} \seclabel{tkfst}

We can cast the TKF Structure Tree (TKFST) model as a transducer.
This means we can automatically deduce rules like those shown for the TKFST model in the main paper.

\subsection{The single-sequence TKFST model as a singlet transducer}

The states of the singlet transducer are shown in \tabref{tkfstsinglet}.
Allowed transitions between these states are shown in the paper.

\begin{table}[!ht]
  \centering
  \begin{tabular}{lrrrr}
    state & $\type$ & $\absorb$ & $\emit$ & $e(\,\bullet\,|\mathrm{TKFST})$ \\ \hline
    $L$ & $\Sstart$ \\
    $I_L$ & $\Sinsert$ & & $(x,\Tnull)$ & $p(x)$ \\
    \\
    $S$ & $\Sstart$ \\
    $I_S$ & $\Sinsert$ & & $(x,y)$ & $p(x,y)$ \\
    \\
    $B$ & $\Sinsert$ & & $(L\,S)$ & 1 \\
  \end{tabular}
  \caption{
    \tablabel{tkfstsinglet}
    States of the singlet transducer of the TKF Structure Tree model \cite{Holmes2004}.
    Singlet transducers can only have states of type $\Sstart$ or $\Sinsert$.
    This is the indiegram-style transducer equivalent of the singlet TKFST SCFG in the main paper.
  }
\end{table}


\subsection{The two-sequence TKFST model as a branch transducer}

The states of the branch transducer are shown in \tabref{tkfstbranch}.
Allowed transitions between these states are shown in the paper.

\begin{table}[!ht]
  \centering
  \begin{tabular}{lrrrr}
    state & $\type$ & $\absorb$ & $\emit$ & $e(\,\bullet\,|\mathrm{TKFST})$ \\ \hline
    $L$ & $\Sstart$ \\
    $I_L$ & $\Sinsert$ & & $(u,\Tnull)$ & $p(u)$ \\
    $M_L$ & $\Smatch$ & $(x,\Tnull)$ & $(u,\Tnull)$ & $p(u|x)$ \\
    $D_L$ & $\Smatch$ & $(x,\Tnull)$ & $(\Tgap,\Tnull)$ & 1 \\
    $W_L$ & $\Swait$ \\
    \\
    $S$ & $\Sstart$ \\
    $I_S$ & $\Sinsert$ & & $(u,v)$ & $p(u,v)$ \\
    $M_S$ & $\Smatch$ & $(x,y)$ & $(u,v)$ & $p(u,v|x,y)$ \\
    $D_S$ & $\Smatch$ & $(x,y)$ & $(\Tgap,\Tgap)$ & 1 \\
    $W_S$ & $\Swait$ \\
    \\
    $B_i$ & $\Sinsert$ & & $(L_i\,S_i)$ & 1 \\
    $B$ & $\Smatch$ & $(L\,S)$ & $(L\,S)$ & 1 \\
    $B_p$ & $\Smatch$ & $(L\,S)$ & $(L\,\Send)$ & 1 \\
    $B_e$ & $\Smatch$ & $(L\,\Send)$ & $(L\,\Send)$ & 1 \\
  \end{tabular}
  \caption{\tablabel{tkfstbranch}
    States of the branch transducer of the TKF Structure Tree model \cite{Holmes2004}.
    States which have the same names as states of the singlet transducer in \tabref{tkfstsinglet}
    are the branch equivalent of the corresponding singlet states
    (e.g. a $\Smatch$ state might be the branch equivalent of an $\Sinsert$ state).
    States $L_i$ and $S_i$ are the $\Sstart$ states of a sub-model (not shown) identical
    in structure to the singlet transducer.  They are used to insert a new stem-loop structure.
    This is the indiegram-style transducer equivalent of the conditional pair TKFST SCFG in the main paper.
  }
\end{table}




\subsection{The multi-sequence TKFST model as a composite transducer}

We can use the state graph construction algorithm described 
in the paper and detailed in \secref{stategraph} to create a model of the simultaneous evolution
of several sequences.

\begin{figure}[!htb]
  \centering
  \includegraphics [scale=0.4] {figs/parent.pdf}
  \caption{\figlabel{parent}
    A simple example of transducer composition to build a multi-sequence model of two extant sequences.
    An ancestral sequence $W$ evolves into two descendant sequences $X$ and $Y$.
    A singlet transducer (the horizontal gray box) emit ancestral sequence and structure
    and two branch transducers (the gray boxes labeled $\Delta T_X$ and $\Delta T_Y$)
    mutate it according to the specified multi-sequence model.
    Gray nodes correspond to observed data and white nodes unobserved data.
  }
\end{figure}

Consider the simple model shown in \figref{parent}.
The state of the multi-sequence model describing this model is a 3-vector $\bvec{a} = \left( a_1,\,a_2,\,a_3 \right)$,
where $a_1$ is the state of the singlet transducer generating the ancestral sequence $W$
and $a_2$ and $a_3$ are the states of the branch transducers evolving $W$ into
extant sequences $X$ and $Y$.

We can show some of the allowed transitions of this multi-sequence model.
The state of the branch transducer associated with the active node $n$ is shown in bold.

\paragraph{Stem creation.}

A stem is created at the root node $W$ (corresponding to a bifurcation in the singlet transducer $a_1$)
and survives in the sequence $X$ at node 2 but is deleted in the sequence $Y$ at node 3.

\begin{align}
  \nakedthreevec{1:}{2:}{3:} \quad
  \threevec{L}{L}{\mathbf{L}} &
  \to \threevec{\mathbf{L}}{W_L}{W_L}
  \to \threevec{B}{B}{B_p}
  \to \threevec{L}{L}{\mathbf{L}} \, \threevec{S}{\mathbf{S}}{\Send}
  \to \threevec{L}{L}{\mathbf{L}} \, \threevec{\mathbf{S}}{W_S}{\Send} \\
  & \to \threevec{\mathbf{L}}{W_L}{W_L} \, \threevec{\mathbf{S}}{W_S}{\Send}
\end{align}


\paragraph{Stem insertion.}

A stem sequence is inserted in sequence $X$ at node 2.

\begin{align}
  \nakedthreevec{1:}{2:}{3:} \quad
  \threevec{L}{L}{\mathbf{L}} \to \threevec{L}{\mathbf{L}}{W_L}
  \to \threevec{L}{B_i}{B}
  \to \threevec{L}{L}{\mathbf{L}} \, \threevec{\Send}{S}{\mathbf{S}}
  \to \threevec{\mathbf{L}}{W_L}{W_L} \, \threevec{\Send}{\mathbf{S}}{W_S}
\end{align}

\paragraph{Stem termination.}

All stem sequences are ended by (possibly empty) loop sequences.

\begin{align}
  \nakedthreevec{1:}{2:}{3:} \quad
  \threevec{\mathbf{S}}{W_S}{W_S}
  \to \threevec{B_e}{B_e}{B_e}
  \to \threevec{\Send}{\Send}{\Send} \, \threevec{L}{L}{\mathbf{L}}
  \to \threevec{\Send}{\Send}{\Send} \, \threevec{\Send}{\Send}{\Send}
\end{align}


The functions $\alpha(t)$, $\beta(t)$ and $\gamma(t)$ are parametrized by the insertion and deletion rates of the Structure Tree model.
They are defined for loop sequences as
\begin{align}
  \kappa_1 &= \lambda_1 / \mu_1 \\
  \alpha_1 &= \exp \left( -\mu_1 t \right) \\
  \beta_1 &= \frac{\lambda_1 \left( 1 - \exp \left((\lambda_1 - \mu_1) t \right) \right)}{\mu_1 - \lambda_1 \exp \left( (\lambda_1 - \mu_1) t \right) } \\
  \gamma_1 &= 1 - \frac{\mu_1 \left( 1 - \exp \left((\lambda_1 - \mu_1) t \right) \right)}{\left( 1 - \exp (- \mu_1 t) \right) \left(\mu_1 - \lambda_1 \exp \left( (\lambda_1 - \mu_1) t \right) \right) }
\end{align}
and similarly for stem sequences \cite{Holmes2004}.


\newpage
\input{tkfst.tex}

\newpage
\section{Software}

We have written software tools in Perl and C++ implementing much of the theory described here.
All tools are available from \darturl\ as part of the \dart\ software package for sequence analysis.

\subsection{Automated grammar construction}
We implemented our model construction algorithm on the star phylogeny (\figref{threeway}) 
in a set of Perl scripts.
Given a singlet transducer modeling ancestral sequences and structures and
a branch transducer modeling structural evolution,
the scripts generate C++ code to create the corresponding jointly-normalized SCFG.
All possible models of structural evolution which can be represented by a Pair SCFG
are permitted as input to the scripts,
allowing for flexible and automated model design.

Given files describing the singlet and branch transducers,
including weights of all transitions which may be functions of evolutionary distance,
the package ComposedTreeTransducer::FourWayComposedTT can automatically generate
the state graph and transition matrix of a multi-sequence model of three extant sequences
(\figref{threeway}).
It removes the useless windback $\Snull$ states described in the paper and
introduces effective direct transitions caused by bifurcations with possibly-empty children.
The package ComposedTreeTransducer::TripletSCFG transforms a multi-sequence
model created by ComposedTreeTransducer::FourWayComposedTT into the 
corresponding jointly-normalized three-sequence SCFG (\secref{multigrammars})
and generates C++ code to build the model.

Example singlet and branch transducers files are provided for a simple 
Pair HMM model, a simple Pair SCFG model and the full TKF Structure Tree model.

\subsection{Reconstruction of ancestral structures}
The program \indiegram\ can perform maximum-likelihood inference on the
three-sequence SCFGs automatically generated by the ComposedTreeTransducer::TripletSCFG package.
Complete or no structural information for the three extant sequences can be supplied
as input.

\subsection{Simulation of RNA family evolution}
The program that we wrote to simulate RNA structural alignments from the TKFST model, \evolsayer, is available as part of the same software distribution as \indiegram\ (the \dart\ package).
Another script (\animateevolsayer) can be used to make animations of the evolving RNA structures, in combination with the RNAplot program in the \viennarna\ package \cite{HofackerEtAl94}.



\newpage
\section{Computational experiments}

\subsection{Reconstruction of covariant substitution histories}

Our \xrate\ program is a multiple-alignment analysis tool
that estimates rate parameters for a broad class of models, including covariant RNA substitution models \cite{KlostermanEtAl2006}.
It can also be used to predict consensus secondary structures for alignments.
We implemented ancestral sequence reconstruction in \xrate, including posterior probabilities that the reconstructions are correct.

Given a multiple sequence alignment and a phylogenetic tree,
\xrate\ estimates maximum-likelihood values of rate and probability parameters by Expectation Maximization.
During parameter estimation, any unspecified ancestral sequences are summed out using Felsenstein's peeling algorithm.
The new feature is that the program can now find the ancestral sequence that has the highest posterior probability,
contingent on the maximum-likelihood estimates of the model parameters.
During the parameter estimation and ancestral reconstruction steps, the secondary structure may be specified, or it may be summed out as a latent variable.

For the ancestral reconstruction experiments described here,
we assumed that alignment, phylogeny and secondary structure were known,
but that ancestral sequences were unknown.

A simple computational experiment demonstrates the need for covariant substitution models.
We first used \xrate\ to estimate maximum-likelihood parameters for a covariant model of RNA base-pair substitution.
These rates were estimated from ribosomal RNA alignments
derived by \cite{DowellEddy2006} from the European rRNA database \cite{WuytsEtAl2004}.
We also fit a ``naive'' general reversible point-substitution model to these alignments, again using \xrate.
All subsequent results are implicitly conditioned on these maximum-likelihood rate estimates.
Next, we used the companion program SIMGRAM to generate 5000 random alignments (including ancestral sequence),
simulating on a 75-taxon phylogeny from an RNA gene family in the \RFAM\ database \cite{GriffithsJonesEtAl2003}.
(Specifically, we chose the type-I Hammerhead ribozyme, one of the 5\% most populous \RFAM\ families.
 We repeated this experiment with other \RFAM\ phylogenies, but the general trends reported here were not dependent on the choice of tree.)
We stripped the ancestral sequence out of the simulated alignments (leaving the true structure annotation intact),
then re-estimated the ancestral sequence with \xrate, using both the (correct) covariant substitution model and the (naive) non-covariant point-substitution model.
The imputed ancestral sequences were compared to the true sequences (known from the simulation),
and the model-derived posterior probabilities were compared to the empirical accuracy of the corresponding reconstructed sequence.

\begin{figure}[ht]
  \begin{center}
     \includegraphics [width=0.45\textwidth] {figs/hammer_paired.pdf}
     \hspace*{\fill}
     \includegraphics [width=0.45\textwidth] {figs/xval_paired.pdf}
  \end{center}
  \caption{
    \figlabel{simulation}
    Accuracy of confidence estimates for base-pair reconstruction in simulations (left) and cross-validations on real data (right).
    Reconstructions were performed using \xrate\ \cite{KlostermanEtAl2006},
    using both covariant base-pair substitution models
    and naive, non-covariant, single-base point-substitution models.
    The plots show the relationship between the posterior probability that a model-based base-pair reconstruction is correct (vertical axis),
    and the empirical probability that reconstructions with that posterior probability are actually correct (horizontal axis).
    If the model's posterior probability estimates are correct, these points should lie on a straight diagonal line.
    Left: simulation test on the hammerhead ribozyme phylogeny.
    A covariant model (estimated from rRNA alignments) was used to generate the simulated alignments on the given phylogeny; the same model was then used to reconstruct ancestral sequence and obtain confidence estimates.
    As expected, the model accurately estimates the probability that the reconstructed base-pair is correct.
    A naive, non-covariant model (the general reversible model, estimated from the same alignments) was also used for reconstruction and confidence estimates.
    This model {\em under}-estimates the probability of correct reconstructions,
    since its equilibrium frequency has a higher entropy than the covariant model:
    i.e. it assigns probability more evenly across the sixteen possible base-pairs (as opposed to the covariant model, which strongly favors the six canonical base-pairs).
    Right: cross-validation (``hold-one-out'') test using \RFAM\ alignments with published (verified) structures.
    Here, the covariant model slightly {\em over}-estimates the probability of correctness.
    The rRNA alignments (from which the model rates were estimated) have fewer non-canonical base-pairs than the \RFAM\ alignments,
    so that the covariant model entropy is slightly {\em lower} than the empirical base-pair distribution;
    this may explain the discrepancy.
    The naive model's confidence estimates are correct
    for high-accuracy reconstructions,
    over-estimates for medium-accuracy reconstructions,
    and under-estimates for low-accuracy reconstructions.
  }
\end{figure}

\figref{simulation} (left) shows the results of these comparisons.
When using the same (covariant) model for simulation and reconstruction, the posterior probabilities are an excellent unbiased estimate of the frequency with which the model reconstructions are correct.
However, the naive point-substitution model, which does not include covariant substitutions at base-paired sites, systematically under-estimates these probabilities.
% perl -e '$f=shift;for$m(qw(g n)){print "$m: ",100 * `grep "$m= 0" $f | wc -l` / `wc -l $f`,"\n"}' Hammerhead_1.bptest
In our simulation, the ancestral error rate for the naive model (4.9\%) was significantly higher than that of the covariant model (1.7\%).
% perl -e '$f=shift;for$m(qw(g n)){print "$m: ",100 * `grep "$m= 0" $f | grep "${m}can= 0" | wc -l` / `grep "$m= 0" $f | wc -l`,"\n"}' Hammerhead_1.bptest
Furthermore, 74\% of incorrect base-pairs predicted by the naive model were non-canonical (i.e. not AU, CG, GC, UA, GU or UG),
compared to only 2\% of incorrect predictions by the covariant model.

\begin{figure}[p]
  \begin{center}
     \includegraphics [width=0.45\textwidth] {figs/hammer_hist.pdf}
     \hspace*{\fill}
     \includegraphics [width=0.45\textwidth] {figs/xval_hist.pdf}
  \end{center}
  \caption{
    \figlabel{histograms}
    Proportions of reconstructed base-pairs that are incorrect (and the subset of those that are non-canonical)
    in simulations (left) and cross-validations on real data (right).
    Base-pair reconstructions that are incorrect AND non-canonical
    might potentially disrupt a synthetic reconstructed structure.
    While the covariant model does not always get more base-pairs correct than the naive model,
    it predicts fewer non-canonical base-pairs.
    The sharpest difference between the models are in the lowest posterior-probability categories,
    corresponding to low-confidence predictions (e.g. sequences on deep branches, or base-pairs with few homologues).
    In this category, the covariant model also makes far fewer errors than the naive model.
    See main text and caption to \figref{simulation} for details of simulation and cross-validation procedures.
    \RFAM\ families with verified structures tended to be less phylogenetically diverse,
    with roughly half the total branch length (on average), than the tree used for our simulations;
    this may explain the relative paucity of low posterior-probability errors in the right-hand plot, compared to the left.
% perl -e 'use Newick;use Stockholm::Database;$db=Stockholm::Database->from_file(shift);for$a(@$db){next if$a->columns>500 || @{$a->seqname}>400;$tree=Newick->from_string(@{$a->gf_NH});$b=0;for$l(@{$tree->branch_length}){$b+=$l}print"$b\n"}' ~/rfam/Training/Published.stock | meansd.pl
% perl -e 'use Newick;use Stockholm::Database;$db=Stockholm::Database->from_file(shift);for$a(@$db){$tree=Newick->from_string(@{$a->gf_NH});$b=0;for$l(@{$tree->branch_length}){$b+=$l}print"$b\n"}' ~/rfam/Training/Hammerhead_1.stock
  }
\end{figure}

We also performed cross-validation (hold-one-out) experiments. Starting from \RFAM\ alignments whose secondary structure is labeled ``Published'' (i.e. experimentally validated),
we estimated phylogenetic trees using the neighbor-joining algorithm
with the Jukes-Cantor model,
then removed individual sequences
 and attempted to reconstruct them using \xrate.
(This is possible because the substitution models are time-reversible, so we can treat any node as ancestral.)
In this experiment, the error rates for base-pair reconstructions again differed by a few percent, though both error rates were higher than in the simulation test
% perl -e '$f=shift;for$m(qw(g n)){print "$m: ",100 * `grep "$m= 0" $f | wc -l` / `wc -l $f`,"\n"}' Published.xval-bptest
(covariant model: 11\%, non-covariant model: 16\%).
% perl -e '$f=shift;for$m(qw(g n)){print "$m: ",100 * `grep "$m= 0" $f | grep "${m}can= 0" | wc -l` / `grep "$m= 0" $f | wc -l`,"\n"}' Published.xval-bptest
Of the incorrectly-reconstructed base-pairs, the non-covariant model again predicted more non-canonical pairs (40\%) than the covariant model (17\%),
especially at lower confidence levels (\figref{histograms}, right).

Posterior probability estimates for both models were
systematically higher in the cross-validation test than they were in the simulation (\figref{simulation}, right).
The presence of this trend in both models
suggests that it may be due to differences between the European rRNA alignments
(from which the rates were estimated)
and the \RFAM\ alignments (which were used in the cross-validation test).
This is confirmed by our empirical observations of
covariant rate matrices estimated from the two alignment datasets:
base-pairs in the \RFAM\ alignments are more frequently
non-canonical, and appear to evolve faster (relative to single-stranded regions),
than base-pairs in the rRNA alignments
(for details, see {\tt biowiki.org/RnaModels}).
Repeating the cross-validation experiment with rates estimated from the \RFAM\ alignments,
we find the covariant model predicted slightly fewer non-canonical base-pairs
% perl -e '$f=shift;for$m(qw(g n)){print "$m: ",100 * `grep "$m= 0" $f | grep "${m}can= 0" | wc -l` / `grep "$m= 0" $f | wc -l`,"\n"}' Published.pubxval-bptest
(14\% rather than 17\%)
and produced slightly more accurate posterior probability estimates (data not shown).
Although this is no longer a strict cross-validation (since parameters were estimated from the test dataset),
it nevertheless emphasizes the value of correct models.
%Another possible source of errors in the cross-validation (compared to the simulation)
%is inaccurately estimated phylogenetic topologies and branch lengths;
%this might be improvable by using a covariant model in the phylogenetic estimation step (rather than Jukes-Cantor),
%and/or by using Bayesian phylogenetic estimation tools (rather than neighbor-joining).

Accurate estimates of posterior probabilities are likely to be important:
sub-optimal predictions are a significant piece of the reconstruction puzzle \cite{WilliamsEtAl2006,PollockChang2007,ChangEtAl2007}.
Ancestral reconstruction by probabilistic modeling does not yield a single definitive sequence, but rather a probability distribution over sequences.
Combinatorial synthesis by degenerate primer assembly has been advocated as a means of sampling from this distribution \cite{Gaucher2007}.
Nucleotide-perfect reconstructions may not always be possible:
it may be more productive to aim for accurate confidence estimates
(including sub-optimal predictions)
than to focus exclusively on getting everything right the first time.

Based on these tests, we conclude that deep phylogenetic reconstructions of ribosomes, and other RNAs, will require covariant substitution models that take account of RNA secondary structure.
We may reasonably deduce that indel reconstructions will, similarly, need to take account of RNA structure.
These results, therefore, strongly motivate the development of multi-sequence models for RNA structure, such as the TKF Structure Tree.



\section{Terminological asides}

This subsection contains some asides about terminology,
and can be omitted on a first reading of this paper.
The intent of this subsection is to highlight connections to related fields
in molecular evolution and computer science.

\subsection{Phylogenetic grammars}

We here describe some relationships to grammar models in current use in molecular evolution.

% Removing this sentence since I do not think that describing the relationship between transducers and SCFGs as an "injective mapping" will make it any clearer for most readers -- it is a bit like describing a string as a "concatenative monoid" -- IH
%There exists an injective mapping from the evolutionary models generated by our model-construction algorithm to multi-sequence SCFGs. In other words, 
Given a singlet transducer, a phylogenetic tree, and a mapping from tree to branch transducers,
the transducer composition algorithm returns a corresponding multi-sequence SCFG
which models the joint probability distribution $P(X_1 , ... , X_{n+m})$.

Several related bioinformatics grammars can be represented within this multi-SCFG framework,
allowing for substantial re-use of prior modeling theory:
\begin{itemize}
\item String transducers (which are similar to HMMs) can be viewed as special cases of parse-tree transducers,
without the facility to model long-distance correlations (base-pairs) or bifurcated structures.
\item Phylo-HMMs and phylo-SCFGs \cite{KlostermanEtAl2006}
can be viewed as special cases of (respectively) string transducers and parse-tree transducers.
(Phylo-HMMs and phylo-SCFGs typically model substitutions but not indels,
and so can be viewed as compositions of a richly-featured singleton transducer with a restricted class of branch transducers.)
\item Sakakibara \cite{Sakakibara2003} has described ``Pair HMMs on tree structures'' that are closely related to our parse-tree transducers
(though without the composition algorithms for scoring multiple alignments).
\item Sakakibara has also described pair stochastic tree-adjoining grammars, or TAGs \cite{Sakakibara2004}.
TAGs are a formal generalization of SCFGs to
mildly context-sensitive grammars \cite{MamitsukaAbe94,JoshiSchabes97,RivasEddy2000}.
We speculate that the conditionally-normalized transducer analogues of such Pair-TAGs may encompass the
phylogenetic model of covariant RNA substitutions and indels on pseudoknotted structures
described by \cite{MeyerMiklos2007},
just as parse-tree transducers encompass phylo-SCFGs.
\end{itemize}

\subsection{Statistical Alignment}

The term {\bf Statistical Alignment} was introduced by Hein \cite{HeinEtal2000}
to describe DP algorithms for phylogenetic grammars.
Although this term has been adopted by others in molecular evolution \cite{Miklos2002,Metzler2003,DrummondRambaut2007,SatijaEtAl2008},
we've avoided it (except in this section) for the following four reasons:
(i) Several RNA alignment methods already use another probability distribution
that's completely different to (though equally as valid as) the phylogenetic probability distribution over alignments:
namely, the Boltzmann probability distribution over secondary structures
\cite{GorodkinEtAl97,MathewsTurner02,HofackerEtAl2004}.
(ii) Many alignment tools make use of prior and posterior distributions over pairwise alignments
\cite{Miyazawa94,BucherHofmann96,Holmes98,BrayPachter2004,DoEtAl2004,Holmes2005,LoytynojaGoldman2005,SchwartzPachter2007,BradleyPachterHolmes2008};
all of these are arguably ``statistical'' alignment tools as well.
(iii) Some of the above-cited methods use sum-over-pairs alignment metrics, taking the expectation of such metrics over pairwise alignment posteriors,
and finding the multiple alignment that maximizes this expectation \cite{DoEtAl2004,SchwartzPachter2007,BradleyPachterHolmes2008};
others do progressive multiple alignment using pair grammars \cite{BrayPachter2004,Holmes2005,LoytynojaGoldman2005}.
Speculatively, such pair-based heuristics may (in some sense) approximate probabilistic alignment inference with true phylogenetic likelihoods;
similar convergences have, at least, been demonstrated between other pair-based heuristics \cite{EickmeyerEtAl2008}.
Thus, even using Hein's strict definition,
it's possible that a broad range of methods systematically {\em approximate} ``Statistical Alignment'';
this cautions against using the term too exclusively.
(iv) Even more broadly, many alignment tools make use of statistics to estimate alignment ``significance''.
In this frequentist approach, probability distributions for alignment scores (particularly Gumbel distributions)
are estimated for random sequences.
The tail integrals of these distributions then yield P-values for high-scoring database search results
\cite{KarlinAltschul93,Mott2000,Eddy2008}.
Thus, while the term ``Statistical Alignment'' has a quite specific technical meaning in molecular evolution
(a meaning which certainly encompasses the algorithms we describe here),
the broader bioinformatics literature may have competing claims to the term.
In any case, the goal of this work is statistical {\em reconstruction} of RNA protosequences,
rather than alignment {\em per se}.

\subsection{Parse trees and stacks}

Grammars are abstract models for languages;
finite-state automata are the corresponding abstract models for those languages' parsers.
Most of this paper uses the grammatical view of RNA structure evolution;
in this short section we digress briefly to mention the automata-theoretic view of these models.

The two non-local features that set SCFGs apart from HMMs are bifurcations and paired emissions \cite{Durbin98}.
In RNA structure analysis, these features are used to model (respectively) branched-loops and base-pairs.

A stochastic pushdown automaton can also model these features.
Such an automaton is essentially an HMM with a LIFO stack (LIFO = ``Last In, First Out'').

The pushdown automaton can parse two sequences simultaneously, aligning them and their parse trees.
It handles bifurcations and paired emissions by pushing symbols onto its stack:
a bifurcation by pushing a nonterminal, and a paired emission by pushing a terminal.
The pushed terminals and nonterminals are popped off the stack when the machine reaches its $\Send$ state.

The conditionally-normalized version of a pushdown automaton is a pushdown transducer:
a machine that absorbs {\em and} parses an input sequence (or absorbs an already-parsed input sequence)
and emits a (parsed) output sequence.
This is the machine that we describe as a parse-tree transducer.



\bibliography{../latex-inputs/alignment,../latex-inputs/reconstruction,../latex-inputs/duplication,../latex-inputs/genomics,../latex-inputs/ncrna,../latex-inputs/url}



\end{document}
